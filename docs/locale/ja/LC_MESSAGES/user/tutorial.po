# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019 Falcon Contributors
# This file is distributed under the same license as the Falcon package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Falcon 1.4dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-06 19:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../user/tutorial.rst:4
msgid "Tutorial"
msgstr ""

#: ../../user/tutorial.rst:6
msgid ""
"In this tutorial we'll walk through building an API for a simple image "
"sharing service. Along the way, we'll discuss Falcon's major features and"
" introduce the terminology used by the framework."
msgstr ""

#: ../../user/tutorial.rst:11
msgid "First Steps"
msgstr ""

#: ../../user/tutorial.rst:13
msgid ""
"The first thing we'll do is :ref:`install <install>` Falcon inside a "
"fresh `virtualenv <http://docs.python-"
"guide.org/en/latest/dev/virtualenvs/>`_. To that end, let's create a new "
"project folder called \"look\", and set up a virtual environment within "
"it that we can use for the tutorial:"
msgstr ""

#: ../../user/tutorial.rst:27
msgid ""
"It's customary for the project's top-level module to be called the same "
"as the project, so let's create another \"look\" folder inside the first "
"one and mark it as a python module by creating an empty ``__init__.py`` "
"file in it:"
msgstr ""

#: ../../user/tutorial.rst:36
msgid "Next, let's create a new file that will be the entry point into your app:"
msgstr ""

#: ../../user/tutorial.rst:42
msgid "The file hierarchy should now look like this:"
msgstr ""

#: ../../user/tutorial.rst:52
msgid ""
"Now, open ``app.py`` in your favorite text editor and add the following "
"lines:"
msgstr ""

#: ../../user/tutorial.rst:60
msgid ""
"This code creates your WSGI application and aliases it as ``api``. You "
"can use any variable names you like, but we'll use ``application`` since "
"that is what Gunicorn, by default, expects it to be called (we'll see how"
" this works in the next section of the tutorial)."
msgstr ""

#: ../../user/tutorial.rst:66
msgid ""
"A WSGI application is just a callable with a well-defined signature so "
"that you can host the application with any web server that understands "
"the `WSGI protocol <http://legacy.python.org/dev/peps/pep-3333/>`_."
msgstr ""

#: ../../user/tutorial.rst:70
msgid ""
"Next let's take a look at the :class:`falcon.API` class. Install `IPython"
" <http://ipython.org/>`_ and fire it up:"
msgstr ""

#: ../../user/tutorial.rst:78
msgid "Now, type the following to introspect the :class:`falcon.API` callable:"
msgstr ""

#: ../../user/tutorial.rst:86
msgid "Alternatively, you can use the standard Python ``help()`` function:"
msgstr ""

#: ../../user/tutorial.rst:92
msgid ""
"Note the method signature. ``env`` and ``start_response`` are standard "
"WSGI params. Falcon adds a thin abstraction on top of these params so you"
" don't have to interact with them directly."
msgstr ""

#: ../../user/tutorial.rst:96
msgid ""
"The Falcon framework contains extensive inline documentation that you can"
" query using the above technique."
msgstr ""

#: ../../user/tutorial.rst:101
msgid ""
"In addition to `IPython <http://ipython.org/>`_, the Python community "
"maintains several other super-powered REPLs that you may wish to try, "
"including `bpython <http://bpython-interpreter.org/>`_ and `ptpython "
"<https://github.com/jonathanslenders/ptpython>`_."
msgstr ""

#: ../../user/tutorial.rst:109
msgid "Hosting Your App"
msgstr ""

#: ../../user/tutorial.rst:111
msgid ""
"Now that you have a simple Falcon app, you can take it for a spin with a "
"WSGI server. Python includes a reference server for self-hosting, but "
"let's use something more robust that you might use in production."
msgstr ""

#: ../../user/tutorial.rst:115
msgid "Open a new terminal and run the following:"
msgstr ""

#: ../../user/tutorial.rst:123
msgid ""
"(Note the use of the ``--reload`` option to tell Gunicorn to reload the "
"app whenever its code changes.)"
msgstr ""

#: ../../user/tutorial.rst:126
msgid ""
"If you are a Windows user, Waitress can be used in lieu of Gunicorn, "
"since the latter doesn't work under Windows:"
msgstr ""

#: ../../user/tutorial.rst:134
msgid "Now, in a different terminal, try querying the running app with curl:"
msgstr ""

#: ../../user/tutorial.rst:140
msgid ""
"You should get a 404. That's actually OK, because we haven't specified "
"any routes yet. Falcon includes a default 404 response handler that will "
"fire for any requested path for which a route does not exist."
msgstr ""

#: ../../user/tutorial.rst:144
msgid ""
"While curl certainly gets the job done, it can be a bit crufty to use. "
"`HTTPie <https://github.com/jkbr/httpie>`_ is a modern, user-friendly "
"alternative. Let's install HTTPie and use it from now on:"
msgstr ""

#: ../../user/tutorial.rst:158
msgid "Creating Resources"
msgstr ""

#: ../../user/tutorial.rst:160
msgid ""
"Falcon's design borrows several key concepts from the REST architectural "
"style."
msgstr ""

#: ../../user/tutorial.rst:163
msgid ""
"Central to both REST and the Falcon framework is the concept of a "
"\"resource\". Resources are simply all the things in your API or "
"application that can be accessed by a URL. For example, an event booking "
"application may have resources such as \"ticket\" and \"venue\", while a "
"video game backend may have resources such as \"achievements\" and "
"\"player\"."
msgstr ""

#: ../../user/tutorial.rst:170
msgid ""
"URLs provide a way for the client to uniquely identify resources. For "
"example, ``/players`` might identify the \"list of all players\" "
"resource, while ``/players/45301f54`` might identify the \"individual "
"player with ID 45301f54\", and ``/players/45301f54/achievements`` the "
"\"list of all achievements for the player resource with ID 45301f54\"."
msgstr ""

#: ../../user/tutorial.rst:182
msgid ""
"In the REST architectural style, the URL only identifies the resource; it"
" does not specify what action to take on that resource. Instead, users "
"choose from a set of standard methods. For HTTP, these are the familiar "
"GET, POST, HEAD, etc. Clients can query a resource to discover which "
"methods it supports."
msgstr ""

#: ../../user/tutorial.rst:190
msgid ""
"This is one of the key differences between the REST and RPC architectural"
" styles. REST applies a standard set of verbs across any number of "
"resources, as opposed to having each application define its own unique "
"set of methods."
msgstr ""

#: ../../user/tutorial.rst:195
msgid ""
"Depending on the requested action, the server may or may not return a "
"representation to the client. Representations may be encoded in any one "
"of a number of Internet media types, such as JSON and HTML."
msgstr ""

#: ../../user/tutorial.rst:199
msgid ""
"Falcon uses Python classes to represent resources. In practice, these "
"classes act as controllers in your application. They convert an incoming "
"request into one or more internal actions, and then compose a response "
"back to the client based on the results of those actions."
msgstr ""

#: ../../user/tutorial.rst:213
msgid ""
"A resource in Falcon is just a regular Python class that includes one or "
"more methods representing the standard HTTP verbs supported by that "
"resource. Each requested URL is mapped to a specific resource."
msgstr ""

#: ../../user/tutorial.rst:217
msgid ""
"Since we are building an image-sharing API, let's start by creating an "
"\"images\" resource. Create a new module, ``images.py`` next to "
"``app.py``, and add the following code to it:"
msgstr ""

#: ../../user/tutorial.rst:247
msgid ""
"As you can see, ``Resource`` is just a regular class. You can name the "
"class anything you like. Falcon uses duck-typing, so you don't need to "
"inherit from any sort of special base class."
msgstr ""

#: ../../user/tutorial.rst:251
msgid ""
"The image resource above defines a single method, ``on_get()``. For any "
"HTTP method you want your resource to support, simply add an ``on_*()`` "
"method to the class, where ``*`` is any one of the standard HTTP methods,"
" lowercased (e.g., ``on_get()``, ``on_put()``, ``on_head()``, etc.)."
msgstr ""

#: ../../user/tutorial.rst:258
msgid ""
"Supported HTTP methods are those specified in `RFC 7231 "
"<https://tools.ietf.org/html/rfc7231>`_ and `RFC 5789 "
"<https://tools.ietf.org/html/rfc5789>`_. This includes GET, HEAD, POST, "
"PUT, DELETE, CONNECT, OPTIONS, TRACE, and PATCH."
msgstr ""

#: ../../user/tutorial.rst:263
msgid ""
"We call these well-known methods \"responders\". Each responder takes (at"
" least) two params, one representing the HTTP request, and one "
"representing the HTTP response to that request. By convention, these are "
"called ``req`` and ``resp``, respectively. Route templates and hooks can "
"inject extra params, as we shall see later on."
msgstr ""

#: ../../user/tutorial.rst:269
msgid ""
"Right now, the image resource responds to GET requests with a simple "
"``200 OK`` and a JSON body. Falcon's Internet media type defaults to "
"``application/json`` but you can set it to whatever you like. Noteworthy "
"JSON alternatives include `YAML <http://yaml.org/>`_ and `MessagePack "
"<http://msgpack.org/>`_."
msgstr ""

#: ../../user/tutorial.rst:275
msgid ""
"Next let's wire up this resource and see it in action. Go back to "
"``app.py`` and modify it so that it looks something like this:"
msgstr ""

#: ../../user/tutorial.rst:290
msgid ""
"Now, when a request comes in for ``/images``, Falcon will call the "
"responder on the images resource that corresponds to the requested HTTP "
"method."
msgstr ""

#: ../../user/tutorial.rst:294
msgid ""
"Let's try it. Restart Gunicorn (unless you're using ``--reload``), and "
"send a GET request to the resource:"
msgstr ""

#: ../../user/tutorial.rst:301
msgid ""
"You should receive a ``200 OK`` response, including a JSON-encoded "
"representation of the \"images\" resource."
msgstr ""

#: ../../user/tutorial.rst:306
msgid ""
"``add_route()`` expects an instance of the resource class, not the class "
"itself. The same instance is used for all requests. This strategy "
"improves performance and reduces memory usage, but this also means that "
"if you host your application with a threaded web server, resources and "
"their dependencies must be thread-safe."
msgstr ""

#: ../../user/tutorial.rst:313
msgid ""
"So far we have only implemented a responder for GET. Let's see what "
"happens when a different method is requested:"
msgstr ""

#: ../../user/tutorial.rst:320
msgid ""
"This time you should get back ``405 Method Not Allowed``, since the "
"resource does not support the ``PUT`` method. Note the value of the Allow"
" header:"
msgstr ""

#: ../../user/tutorial.rst:328
msgid ""
"This is generated automatically by Falcon based on the set of methods "
"implemented by the target resource. If a resource does not include its "
"own OPTIONS responder, the framework provides a default implementation. "
"Therefore, OPTIONS is always included in the list of allowable methods."
msgstr ""

#: ../../user/tutorial.rst:336
msgid ""
"If you have a lot of experience with other Python web frameworks, you may"
" be used to using decorators to set up your routes. Falcon's particular "
"approach provides the following benefits:"
msgstr ""

#: ../../user/tutorial.rst:340
msgid ""
"The URL structure of the application is centralized. This makes it easier"
" to reason about and maintain the API over time."
msgstr ""

#: ../../user/tutorial.rst:342
msgid ""
"The use of resource classes maps somewhat naturally to the REST "
"architectural style, in which a URL is used to identify a resource only, "
"not the action to perform on that resource."
msgstr ""

#: ../../user/tutorial.rst:345
msgid ""
"Resource class methods provide a uniform interface that does not have to "
"be reinvented (and maintained) from class to class and application to "
"application."
msgstr ""

#: ../../user/tutorial.rst:349
msgid ""
"Next, just for fun, let's modify our resource to use `MessagePack "
"<http://msgpack.org/>`_ instead of JSON. Start by installing the relevant"
" package:"
msgstr ""

#: ../../user/tutorial.rst:357
msgid "Then, update the responder to use the new media type:"
msgstr ""

#: ../../user/tutorial.rst:381
msgid ""
"Note the use of ``resp.data`` in lieu of ``resp.body``. If you assign a "
"bytestring to the latter, Falcon will figure it out, but you can realize "
"a small performance gain by assigning directly to ``resp.data``."
msgstr ""

#: ../../user/tutorial.rst:385
msgid ""
"Also note the use of ``falcon.MEDIA_MSGPACK``. The ``falcon`` module "
"provides a number of constants for common media types, including "
"``falcon.MEDIA_JSON``, ``falcon.MEDIA_MSGPACK``, ``falcon.MEDIA_YAML``, "
"``falcon.MEDIA_XML``, ``falcon.MEDIA_HTML``, ``falcon.MEDIA_JS``, "
"``falcon.MEDIA_TEXT``, ``falcon.MEDIA_JPEG``, ``falcon.MEDIA_PNG``, and "
"``falcon.MEDIA_GIF``."
msgstr ""

#: ../../user/tutorial.rst:392
msgid ""
"Restart Gunicorn (unless you're using ``--reload``), and then try sending"
" a GET request to the revised resource:"
msgstr ""

#: ../../user/tutorial.rst:402
msgid "Testing your application"
msgstr ""

#: ../../user/tutorial.rst:404
msgid ""
"Fully exercising your code is critical to creating a robust application. "
"Let's take a moment to write a test for what's been implemented so far."
msgstr ""

#: ../../user/tutorial.rst:408
msgid ""
"First, create a ``tests`` directory with ``__init__.py`` and a test "
"module (``test_app.py``) inside it. The project's structure should now "
"look like this:"
msgstr ""

#: ../../user/tutorial.rst:424
msgid ""
"Falcon supports :ref:`testing <testing>` its :class:`~.API` object by "
"simulating HTTP requests."
msgstr ""

#: ../../user/tutorial.rst:427
msgid ""
"Tests can either be written using Python's standard :mod:`unittest` "
"module, or with any of a number of third-party testing frameworks, such "
"as `pytest <http://docs.pytest.org/en/latest/>`_. For this tutorial we'll"
" use `pytest <http://docs.pytest.org/en/latest/>`_ since it allows for "
"more pythonic test code as compared to the JUnit-inspired :mod:`unittest`"
" module."
msgstr ""

#: ../../user/tutorial.rst:434
msgid ""
"Let's start by installing the `pytest "
"<http://docs.pytest.org/en/latest/>`_ package:"
msgstr ""

#: ../../user/tutorial.rst:441
msgid "Next, edit ``test_app.py`` to look like this:"
msgstr ""

#: ../../user/tutorial.rst:475
msgid ""
"From the main project directory, exercise your new test by running pytest"
" against the ``tests`` directory:"
msgstr ""

#: ../../user/tutorial.rst:482
msgid ""
"If pytest reports any errors, take a moment to fix them up before "
"proceeding to the next section of the tutorial."
msgstr ""

#: ../../user/tutorial.rst:486
msgid "Request and Response Objects"
msgstr ""

#: ../../user/tutorial.rst:488
msgid ""
"Each responder in a resource receives a ``Request`` object that can be "
"used to read the headers, query parameters, and body of the request. You "
"can use the standard ``help()`` function or IPython's magic ``?`` "
"function to list the attributes and methods of Falcon's ``Request`` "
"class:"
msgstr ""

#: ../../user/tutorial.rst:500
msgid ""
"Each responder also receives a ``Response`` object that can be used for "
"setting the status code, headers, and body of the response:"
msgstr ""

#: ../../user/tutorial.rst:507
msgid ""
"This will be useful when creating a POST endpoint in the application that"
" can add new image resources to our collection. We'll tackle this "
"functionality next."
msgstr ""

#: ../../user/tutorial.rst:511
msgid ""
"We'll use TDD this time around, to demonstrate how to apply this "
"particular testing strategy when developing a Falcon application. Via "
"tests, we'll first define precisely what we want the application to do, "
"and then code until the tests tell us that we're done."
msgstr ""

#: ../../user/tutorial.rst:517
msgid ""
"To learn more about TDD, you may wish to check out one of the many books "
"on the topic, such as `Test Driven Development with Python "
"<http://www.obeythetestinggoat.com/pages/book.html>`_. The examples in "
"this particular book use the Django framework and even JavaScript, but "
"the author covers a number of testing principles that are widely "
"applicable."
msgstr ""

#: ../../user/tutorial.rst:524
msgid ""
"Let's start by adding an additional import statement to ``test_app.py``. "
"We need to import two modules from ``unittest.mock`` if you are using "
"Python 3, or from ``mock`` if you are using Python 2."
msgstr ""

#: ../../user/tutorial.rst:536
msgid "For Python 2, you will also need to install the ``mock`` package:"
msgstr ""

#: ../../user/tutorial.rst:542
msgid "Now add the following test:"
msgstr ""

#: ../../user/tutorial.rst:569
msgid ""
"As you can see, this test relies heavily on mocking, making it somewhat "
"fragile in the face of implementation changes. We'll revisit this later. "
"For now, run the tests again and watch to make sure they fail. A key step"
" in the TDD workflow is verifying that your tests **do not** pass before "
"moving on to the implementation:"
msgstr ""

#: ../../user/tutorial.rst:579
msgid ""
"To make the new test pass, we need to add a new method for handling "
"POSTs. Open ``images.py`` and add a POST responder to the ``Resource`` "
"class as follows:"
msgstr ""

#: ../../user/tutorial.rst:632
msgid ""
"As you can see, we generate a unique name for the image, and then write "
"it out by reading from ``req.stream``. It's called ``stream`` instead of "
"``body`` to emphasize the fact that you are really reading from an input "
"stream; by default Falcon does not spool or decode request data, instead "
"giving you direct access to the incoming binary stream provided by the "
"WSGI server."
msgstr ""

#: ../../user/tutorial.rst:639
msgid ""
"Note the use of ``falcon.HTTP_201`` for setting the response status to "
"\"201 Created\". We could have also used the ``falcon.HTTP_CREATED`` "
"alias. For a full list of predefined status strings, simply call "
"``help()`` on ``falcon.status_codes``:"
msgstr ""

#: ../../user/tutorial.rst:648
msgid ""
"The last line in the ``on_post()`` responder sets the Location header for"
" the newly created resource. (We will create a route for that path in "
"just a minute.) The :class:`~.Request` and :class:`~.Response` classes "
"contain convenient attributes for reading and setting common headers, but"
" you can always access any header by name with the ``req.get_header()`` "
"and ``resp.set_header()`` methods."
msgstr ""

#: ../../user/tutorial.rst:655
msgid "Take a moment to run pytest again to check your progress:"
msgstr ""

#: ../../user/tutorial.rst:661
msgid ""
"You should see a ``TypeError`` as a consequence of adding the "
"``storage_path`` parameter to ``Resource.__init__()``."
msgstr ""

#: ../../user/tutorial.rst:664
msgid ""
"To fix this, simply edit ``app.py`` and pass in a path to the "
"initializer. For now, just use the working directory from which you "
"started the service:"
msgstr ""

#: ../../user/tutorial.rst:672
msgid ""
"Try running the tests again. This time, they should pass with flying "
"colors!"
msgstr ""

#: ../../user/tutorial.rst:679
msgid ""
"Finally, restart Gunicorn and then try sending a POST request to the "
"resource from the command line (substituting ``test.png`` for a path to "
"any PNG you like.)"
msgstr ""

#: ../../user/tutorial.rst:687
msgid ""
"Now, if you check your storage directory, it should contain a copy of the"
" image you just POSTed."
msgstr ""

#: ../../user/tutorial.rst:690
msgid "Upward and onward!"
msgstr ""

#: ../../user/tutorial.rst:693
msgid "Refactoring for testability"
msgstr ""

#: ../../user/tutorial.rst:695
msgid ""
"Earlier we pointed out that our POST test relied heavily on mocking, "
"relying on assumptions that may or may not hold true as the code evolves."
" To mitigate this problem, we'll not only have to refactor the tests, but"
" also the application itself."
msgstr ""

#: ../../user/tutorial.rst:700
msgid ""
"We'll start by factoring out the business logic from the resource's POST "
"responder in ``images.py`` so that it can be tested independently. In "
"this case, the resource's \"business logic\" is simply the image-saving "
"operation:"
msgstr ""

#: ../../user/tutorial.rst:766
msgid "Let's check to see if we broke anything with the changes above:"
msgstr ""

#: ../../user/tutorial.rst:772
msgid "Hmm, it looks like we forgot to update ``app.py``. Let's do that now:"
msgstr ""

#: ../../user/tutorial.rst:787
msgid "Let's try again:"
msgstr ""

#: ../../user/tutorial.rst:793
msgid ""
"Now you should see a failed test assertion regarding ``mock_file_open``. "
"To fix this, we need to switch our strategy from monkey-patching to "
"dependency injection. Return to ``app.py`` and modify it to look similar "
"to the following:"
msgstr ""

#: ../../user/tutorial.rst:816
msgid ""
"As you can see, the bulk of the setup logic has been moved to "
"``create_app()``, which can be used to obtain an API object either for "
"testing or for hosting in production. ``get_app()`` takes care of "
"instantiating additional resources and configuring the application for "
"hosting."
msgstr ""

#: ../../user/tutorial.rst:822
msgid "The command to run the application is now:"
msgstr ""

#: ../../user/tutorial.rst:828
msgid ""
"Finally, we need to update the test code. Modify ``test_app.py`` to look "
"similar to this:"
msgstr ""

#: ../../user/tutorial.rst:901
msgid ""
"As you can see, we've redone the POST. While there are fewer mocks, the "
"assertions have gotten more elaborate to properly check interactions at "
"the interface boundaries."
msgstr ""

#: ../../user/tutorial.rst:904
msgid "Let's check our progress:"
msgstr ""

#: ../../user/tutorial.rst:910
msgid ""
"All green! But since we used a mock, we're no longer covering the actual "
"saving of the image. Let's add a test for that:"
msgstr ""

#: ../../user/tutorial.rst:937
msgid "Now give it a try:"
msgstr ""

#: ../../user/tutorial.rst:943
msgid ""
"Like the former test, this one still uses mocks. But the structure of the"
" code has been improved through the techniques of componentization and "
"dependency inversion, making the application more flexible and testable."
msgstr ""

#: ../../user/tutorial.rst:949
msgid ""
"Checking code `coverage <https://coverage.readthedocs.io/>`_ would have "
"helped us detect the missing test above; it's always a good idea to "
"include coverage testing in your workflow to ensure you don't have any "
"bugs hiding off somewhere in an unexercised code path."
msgstr ""

#: ../../user/tutorial.rst:956
msgid "Functional tests"
msgstr ""

#: ../../user/tutorial.rst:958
msgid ""
"Functional tests define the application's behavior from the outside. When"
" using TDD, this can be a more natural place to start as opposed to "
"lower-level unit testing, since it is difficult to anticipate what "
"internal interfaces and components are needed in advance of defining the "
"application's user-facing functionality."
msgstr ""

#: ../../user/tutorial.rst:964
msgid ""
"In the case of the refactoring work from the last section, we could have "
"inadvertently introduced a functional bug into the application that our "
"unit tests would not have caught. This can happen when a bug is a result "
"of an unexpected interaction between multiple units, between the "
"application and the web server, or between the application and any "
"external services it depends on."
msgstr ""

#: ../../user/tutorial.rst:971
msgid ""
"With test helpers such as ``simulate_get()`` and ``simulate_post()``, we "
"can create tests that span multiple units. But we can also go one step "
"further and run the application as a normal, separate process (e.g. with "
"Gunicorn). We can then write tests that interact with the running process"
" through HTTP, behaving like a normal client."
msgstr ""

#: ../../user/tutorial.rst:977
msgid ""
"Let's see this in action. Create a new test module, "
"``tests/test_integration.py`` with the following contents:"
msgstr ""

#: ../../user/tutorial.rst:1009
msgid ""
"Next, install the ``requests`` package (as required by the new test) and "
"make sure Gunicorn is up and running:"
msgstr ""

#: ../../user/tutorial.rst:1017
msgid "Then, in another terminal, try running the new test:"
msgstr ""

#: ../../user/tutorial.rst:1023
msgid ""
"The test will fail since it expects the image file to reside under "
"``/tmp``. To fix this, modify ``app.py`` to add the ability to configure "
"the image storage directory with an environment variable:"
msgstr ""

#: ../../user/tutorial.rst:1048
msgid "Now you can re-run the app against the desired storage directory:"
msgstr ""

#: ../../user/tutorial.rst:1054
msgid "You should now be able to re-run the test and see it succeed:"
msgstr ""

#: ../../user/tutorial.rst:1061
msgid ""
"The above process of starting, testing, stopping, and cleaning up after "
"each test run can (and really should be) automated. Depending on your "
"needs, you can develop your own automation fixtures, or use a library "
"such as `mountepy <https://github.com/butla/mountepy>`_."
msgstr ""

#: ../../user/tutorial.rst:1067
msgid ""
"Many developers choose to write tests like the above to sanity-check "
"their application's primary functionality, while leaving the bulk of "
"testing to simulated requests and unit tests. These latter types of tests"
" generally execute much faster and facilitate more fine-grained test "
"assertions as compared to higher-level functional and system tests. That "
"being said, testing strategies vary widely and you should choose the one "
"that best suits your needs."
msgstr ""

#: ../../user/tutorial.rst:1075
msgid ""
"At this point, you should have a good grip on how to apply common testing"
" strategies to your Falcon application. For the sake of brevity we'll "
"omit further testing instructions from the following sections, focusing "
"instead on showcasing more of Falcon's features."
msgstr ""

#: ../../user/tutorial.rst:1084
msgid "Serving Images"
msgstr ""

#: ../../user/tutorial.rst:1086
msgid ""
"Now that we have a way of getting images into the service, we of course "
"need a way to get them back out. What we want to do is return an image "
"when it is requested, using the path that came back in the Location "
"header."
msgstr ""

#: ../../user/tutorial.rst:1091
msgid "Try executing the following:"
msgstr ""

#: ../../user/tutorial.rst:1097
msgid ""
"In response, you should get a ``404 Not Found``. This is the default "
"response given by Falcon when it can not find a resource that matches the"
" requested URL path."
msgstr ""

#: ../../user/tutorial.rst:1101
msgid ""
"Let's address this by creating a separate class to represent a single "
"image resource. We will then add an ``on_get()`` method to respond to the"
" path above."
msgstr ""

#: ../../user/tutorial.rst:1105
msgid "Go ahead and edit your ``images.py`` file to look something like this:"
msgstr ""

#: ../../user/tutorial.rst:1193
msgid ""
"As you can see, we renamed ``Resource`` to ``Collection`` and added a new"
" ``Item`` class to represent a single image resource. Alternatively, "
"these two classes could be consolidated into one by using suffixed "
"responders. (See also: :meth:`~falcon.API.add_route`)"
msgstr ""

#: ../../user/tutorial.rst:1198
msgid ""
"Also, note the ``name`` parameter for the ``on_get()`` responder. Any URI"
" parameters that you specify in your routes will be turned into "
"corresponding kwargs and passed into the target responder as such. We'll "
"see how to specify URI parameters in a moment."
msgstr ""

#: ../../user/tutorial.rst:1203
msgid ""
"Inside the ``on_get()`` responder, we set the Content-Type header based "
"on the filename extension, and then stream out the image directly from an"
" open file handle. Note the use of ``resp.content_length``. Whenever "
"using ``resp.stream`` instead of ``resp.body`` or ``resp.data``, you "
"typically also specify the expected length of the stream using the "
"Content-Length header, so that the web client knows how much data to read"
" from the response."
msgstr ""

#: ../../user/tutorial.rst:1210
msgid ""
"If you do not know the size of the stream in advance, you can work around"
" that by using chunked encoding, but that's beyond the scope of this "
"tutorial."
msgstr ""

#: ../../user/tutorial.rst:1214
msgid ""
"If ``resp.status`` is not set explicitly, it defaults to ``200 OK``, "
"which is exactly what we want ``on_get()`` to do."
msgstr ""

#: ../../user/tutorial.rst:1217
msgid ""
"Now let's wire everything up and give it a try. Edit ``app.py`` to look "
"similar to the following:"
msgstr ""

#: ../../user/tutorial.rst:1241
msgid ""
"As you can see, we specified a new route, ``/images/{name}``. This causes"
" Falcon to expect all associated responders to accept a ``name`` "
"argument."
msgstr ""

#: ../../user/tutorial.rst:1247
msgid ""
"Falcon also supports more complex parameterized path segments that "
"contain multiple values. For example, a version control API might use the"
" following route template for diffing two code branches::"
msgstr ""

#: ../../user/tutorial.rst:1253
msgid "Now re-run your app and try to POST another picture:"
msgstr ""

#: ../../user/tutorial.rst:1259
msgid ""
"Make a note of the path returned in the Location header, and use it to "
"GET the image:"
msgstr ""

#: ../../user/tutorial.rst:1266
msgid ""
"HTTPie won't display the image, but you can see that the response headers"
" were set correctly. Just for fun, go ahead and paste the above URI into "
"your browser. The image should display correctly."
msgstr ""

#: ../../user/tutorial.rst:1277
msgid "Introducing Hooks"
msgstr ""

#: ../../user/tutorial.rst:1279
msgid ""
"At this point you should have a pretty good understanding of the basic "
"parts that make up a Falcon-based API. Before we finish up, let's just "
"take a few minutes to clean up the code and add some error handling."
msgstr ""

#: ../../user/tutorial.rst:1283
msgid ""
"First, let's check the incoming media type when something is posted to "
"make sure it is a common image type. We'll implement this with a "
"``before`` hook."
msgstr ""

#: ../../user/tutorial.rst:1287
msgid ""
"Start by defining a list of media types the service will accept. Place "
"this constant near the top, just after the import statements in "
"``images.py``:"
msgstr ""

#: ../../user/tutorial.rst:1299
msgid ""
"The idea here is to only accept GIF, JPEG, and PNG images. You can add "
"others to the list if you like."
msgstr ""

#: ../../user/tutorial.rst:1302
msgid ""
"Next, let's create a hook that will run before each request to post a "
"message. Add this method below the definition of ``ALLOWED_IMAGE_TYPES``:"
msgstr ""

#: ../../user/tutorial.rst:1312
msgid "And then attach the hook to the ``on_post()`` responder:"
msgstr ""

#: ../../user/tutorial.rst:1320
msgid ""
"Now, before every call to that responder, Falcon will first invoke "
"``validate_image_type()``. There isn't anything special about this "
"function, other than it must accept four arguments. Every hook takes, as "
"its first two arguments, a reference to the same ``req`` and ``resp`` "
"objects that are passed into responders. The ``resource`` argument is a "
"Resource instance associated with the request. The fourth argument, named"
" ``params`` by convention, is a reference to the kwarg dictionary Falcon "
"creates for each request. ``params`` will contain the route's URI "
"template params and their values, if any."
msgstr ""

#: ../../user/tutorial.rst:1330
msgid ""
"As you can see in the example above, you can use ``req`` to get "
"information about the incoming request. However, you can also use "
"``resp`` to play with the HTTP response as needed, and you can even use "
"hooks to inject extra kwargs:"
msgstr ""

#: ../../user/tutorial.rst:1344
msgid ""
"Now, you might imagine that such a hook should apply to all responders "
"for a resource. In fact, hooks can be applied to an entire resource by "
"simply decorating the class:"
msgstr ""

#: ../../user/tutorial.rst:1355
msgid ""
"Similar logic can be applied globally with middleware. (See also: "
":ref:`falcon.middleware <middleware>`)"
msgstr ""

#: ../../user/tutorial.rst:1358
msgid ""
"Now that you've added a hook to validate the media type, you can see it "
"in action by attempting to POST something nefarious:"
msgstr ""

#: ../../user/tutorial.rst:1365
msgid ""
"You should get back a ``400 Bad Request`` status and a nicely structured "
"error body."
msgstr ""

#: ../../user/tutorial.rst:1369
msgid ""
"When something goes wrong, you usually want to give your users some info "
"to help them resolve the issue. The exception to this rule is when an "
"error occurs because the user is requested something they are not "
"authorized to access. In that case, you may wish to simply return ``404 "
"Not Found`` with an empty body, in case a malicious user is fishing for "
"information that will help them crack your app."
msgstr ""

#: ../../user/tutorial.rst:1376
msgid "Check out the :ref:`hooks reference <hooks>` to learn more."
msgstr ""

#: ../../user/tutorial.rst:1379
msgid "Error Handling"
msgstr ""

#: ../../user/tutorial.rst:1381
msgid ""
"Generally speaking, Falcon assumes that resource responders "
"(``on_get()``, ``on_post()``, etc.) will, for the most part, do the right"
" thing. In other words, Falcon doesn't try very hard to protect responder"
" code from itself."
msgstr ""

#: ../../user/tutorial.rst:1386
msgid ""
"This approach reduces the number of (often) extraneous checks that Falcon"
" would otherwise have to perform, making the framework more efficient. "
"With that in mind, writing a high-quality API based on Falcon requires "
"that:"
msgstr ""

#: ../../user/tutorial.rst:1390
msgid "Resource responders set response variables to sane values."
msgstr ""

#: ../../user/tutorial.rst:1391
msgid ""
"Untrusted input (i.e., input from an external client or service) is "
"validated."
msgstr ""

#: ../../user/tutorial.rst:1393
msgid "Your code is well-tested, with high code coverage."
msgstr ""

#: ../../user/tutorial.rst:1394
msgid ""
"Errors are anticipated, detected, logged, and handled appropriately "
"within each responder or by global error handling hooks."
msgstr ""

#: ../../user/tutorial.rst:1397
msgid ""
"When it comes to error handling, you can always directly set the error "
"status, appropriate response headers, and error body using the ``resp`` "
"object. However, Falcon tries to make things a little easier by providing"
" a :ref:`set of error classes <predefined_errors>` you can raise when "
"something goes wrong. Falcon will convert any instance or subclass of "
":class:`falcon.HTTPError` raised by a responder, hook, or middleware "
"component into an appropriate HTTP response."
msgstr ""

#: ../../user/tutorial.rst:1405
msgid ""
"You may raise an instance of :class:`falcon.HTTPError` directly, or use "
"any one of a number of :ref:`predefined errors <predefined_errors>` that "
"are designed to set the response headers and body appropriately for each "
"error type."
msgstr ""

#: ../../user/tutorial.rst:1411
msgid ""
"Falcon will re-raise errors that do not inherit from "
":class:`falcon.HTTPError` unless you have registered a custom error "
"handler for that type."
msgstr ""

#: ../../user/tutorial.rst:1415
msgid ""
"Error handlers may be registered for any type, including "
":class:`~.HTTPError`. This feature provides a central location for "
"logging and otherwise handling exceptions raised by responders, hooks, "
"and middleware components."
msgstr ""

#: ../../user/tutorial.rst:1420
msgid "See also: :meth:`~.API.add_error_handler`."
msgstr ""

#: ../../user/tutorial.rst:1422
msgid ""
"Let's see a quick example of how this works. Try requesting an invalid "
"image name from your application:"
msgstr ""

#: ../../user/tutorial.rst:1429
msgid ""
"As you can see, the result isn't exactly graceful. To fix this, we'll "
"need to add some exception handling. Modify your ``Item`` class as "
"follows:"
msgstr ""

#: ../../user/tutorial.rst:1449
msgid "Now let's try that request again:"
msgstr ""

#: ../../user/tutorial.rst:1455
msgid ""
"Additional information about error handling is available in the "
":ref:`error handling reference <errors>`."
msgstr ""

#: ../../user/tutorial.rst:1459
msgid "What Now?"
msgstr ""

#: ../../user/tutorial.rst:1461
msgid ""
"Our friendly community is available to answer your questions and help you"
" work through sticky problems. See also: :ref:`Getting Help <help>`."
msgstr ""

#: ../../user/tutorial.rst:1464
msgid ""
"As mentioned previously, Falcon's docstrings are quite extensive, and so "
"you can learn a lot just by poking around Falcon's modules from a Python "
"REPL, such as `IPython <http://ipython.org/>`_ or `bpython <http"
"://bpython-interpreter.org/>`_."
msgstr ""

#: ../../user/tutorial.rst:1469
msgid ""
"Also, don't be shy about pulling up Falcon's source code on GitHub or in "
"your favorite text editor. The team has tried to make the code as "
"straightforward and readable as possible; where other documentation may "
"fall short, the code basically can't be wrong."
msgstr ""

#: ../../user/tutorial.rst:1474
msgid ""
"A number of Falcon add-ons, templates, and complementary packages are "
"available for use in your projects. We've listed several of these on the "
"`Falcon wiki <https://github.com/falconry/falcon/wiki>`_ as a starting "
"point, but you may also wish to search PyPI for additional resources."
msgstr ""

